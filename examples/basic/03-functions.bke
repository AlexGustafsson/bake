// To help you write reusable logic, you may use functions.
func create_file(name) {
  shell touch $(name)
}

// A similar feature to functions are rule functions. Such functions
// may access information about the build context in a context object.
// It may also be used in place of a rule's body to simplify repeatable rules.
// Also note that functions that don't take any parameters don't need to have
// parentheses after the function's name.
rule file {
  create_file $(context.out)
}

// The newly created rule function may now be used as a component like so:
new-file3.txt : file

// Rule functions may take parameters too.
rule file_with_permissions(chmod) {
  create_file $(context.out)
  shell chmod $(chmod) $(context.out)
}

// Whenever a function takes parameters, they must be specified:
new-file3.txt : file_with_permissions(0660)

// A rule function may also access dependencies, just like regular rules
rule copy_file {
  shell cp $(context.out) $(context.in)
}

// Dependencies for rules generated by functions are specified just like with
// regular rules
copied-file2.txt [new-file.txt] : copy_file

// Any command ran in the body of a rule generated by a function will be called
// after the commands defined in the rule created by the function.
copied-file3.txt [new-file.txt] : copy_file {
  // List the now created file
  shell ls $@
}

// To specify dynamic dependencies for a rule, you may overwrite the context
// of the rule
rule build_module(module) {
  // Wrap a shell command for finding input
  func find_module_source(module) {
    shell find "Sources/$(1)" -type f -name "*.swift
  }

  // Overwrite the input of the context so that Bake may resolve dependencies.
  // This must be done before any other commands
  context.in = find_module_source(module)

  // Build
  shell gcc $(context.in)
}

// The rule may then be used like any other
build/module/app : build_module(app)
