// Bake files can be called Bakefile or use the '.bke' file extension, like this file does.
// Like with Make, Bake uses rules to match source files and destination files with a set of
// commands centered on shell code to "glue" together other programs.

// Each rule has a name. In most cases, this name is the file path of the rule's output.
new-file.txt {
  // As previously mentioned, shell functions are at the core of Bake. These may be written
  // using regular Bash or the like, with commands and programs available on the system.
  shell touch new-file.txt
}

// Like with Make, there are some standard variables defined in each rule. These
// help you write more concise rules without duplicating names.
new-file2.txt {
  // Here we use the '$@' variable instead of re-using the file's name,
  // that way it's easily changable later on.
  shell touch $@
}

// Rules may have dependencies so that Bake knows when to re-run a rule if any
// of its dependencies have been changed. It also helps Bake know in which order
// to run rules.
copied-file.txt {
  // This in(clude) will make sure that new-file.txt is created before this rule
  // is run (by running the rule for it). If the file already exists, it will be
  // used as is and if it doesn't exist at all, an error will be thrown.
  in new-file.txt
  // Just like with output files, input files can be referenced in Bake using the
  // '$<' implicit variable.
  shell cp $< $@
}

// To help you write re-usable rules, you can use functions. Functions in Bake have
// several purposes, but if they return a rule they may be used instead of the rule body
// as shown in the previous examples. Just like with regular rules, rule-generating functions
// may receive dependencies via the rule context.
func create_file(): rule {
  shell touch $(context.out)
}

// The newly created function may now be used as a component like so:
new-file3.txt : create_file

// Functions may take parameters too.
func create_file_with_permission(chmod: number): rule {
  shell touch $(context.out) && chmod $(chmod) $(context.out)
}

// Whenever a function takes parameters, they must be specified:
new-file3.txt : create_file_with_permission(0660)

// A rule-generating function may also access dependencies, just like other rules
func copy_file(): rule {
  shell cp $(context.out) $(context.in)
}

// Dependencies for rules generated by functions are specified just like with
// regular rules
copied-file2.txt : copy_file {
  in new-file.txt
}

// Any command ran in the body of a rule generated by a function will be called
// after the commands defined in the rule created by the function.
copied-file3.txt : copy_file {
  in new-file.txt
  // List the now created file
  shell ls $@
}

// Bake allows for prefix functions. Such a function is basically only
// a regular function that is ran before Bake resolves dependencies.
// A prefix function may be named anything, but when it's used, it's always prefixed with a dot.
// Such functions may be used to add tags to rules. Tags aren't always useful,
// but they act as a building block to provide functionality such as phony rules.
func ignore() {
  context.tags.add("my_tag")
}

// The rule that is run first may be decided in several ways. If no rule is explictly
// chosen, the topmost rule will be run first. Another way to decide what rule to run
// is to create a phony rule called main:
.phony main {
  print("Hello, world!")
}
