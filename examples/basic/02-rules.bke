// Bake files can be called Bakefile or use the '.bke' file extension, like this file does.
// Like with Make, Bake uses rules to match source files and destination files with a set of
// commands centered on shell code to "glue" together other programs.

// Each rule has a name. In most cases, this name is the file path of the rule's output.
new-file.txt {
  // As previously mentioned, shell functions are at the core of Bake. These may be written
  // using regular Bash or the like, with commands and programs available on the system.
  shell touch new-file.txt
}

// Like with Make, there are some standard variables defined in each rule. These
// help you write more concise rules without duplicating names.
new-file2.txt {
  // Here we use the '$@' variable instead of re-using the file's name,
  // that way it's easily changable later on.
  shell touch $@
}

// Rules may have dependencies so that Bake knows when to re-run a rule if any
// of its dependencies have been changed. It also helps Bake know in which order
// to run rules.
copied-file.txt {
  // This in(clude) will make sure that new-file.txt is created before this rule
  // is run (by running the rule for it). If the file already exists, it will be
  // used as is and if it doesn't exist at all, an error will be thrown.
  in new-file.txt
  // Just like with output files, input files can be referenced in Bake using the
  // '$<' implicit variable.
  shell cp $< $@
}

// If you have multiple output files, separate them by spaces.
file1 file2 {
  shell touch file1 file2
}

// Paths containing spaces must be wrapped in quotes.
"file 1" "file 2" {
  shell touch "file 1" "file 2"
}

// The rule that is run first may be decided in several ways. If no rule is explictly
// chosen, the topmost rule will be run first. Another way to decide what rule to run
// is to create a phony rule called main:
.phony main {
  print("Hello, world!")
}
