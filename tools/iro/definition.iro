#################################################################
## Iro
################################################################
##
## * Matches cannot span lines.
## * Unicode chars must be defined in \u0000 to \uffff format.
## * All matches must be contained by a single group ( ... )
## * Look behinds not permitted, (?<= or (?<!
## * Look forwards are permitted (?= or (?!
## * Constants are defined as __my_const = (......)
## * The \= format allows unescaped regular expressions
## * Constants referenced by match \= $${__my_const}
## * Constants can reference other constants
##
################################################################

name = Bake
file_extensions [] = bke;

styles [] {
   .comment : style {
      color = grey
      italic = true
      textmate_scope = comment
      pygments_scope = Comment
   }

   .keyword : style {
      color = cyan
      textmate_scope = keyword
      pygments_scope = Keyword
   }

   .numeric : style {
      color = gold
      textmate_scope = constant.numeric
      pygments_scope = Number
   }

   .punctuation : style {
      color = red_2
      textmate_scope = punctuation
      pygments_scope = Punctuation
   }

   .text : style {
      color = light_green
      textmate_scope = text
      pygments_scope = String
   }

   .illegal : style {
      color = white
      background_color = red
      textmate_scope = invalid
      pygments_scope = Generic.Error
   }

   .import : style {
      color = purple
      textmate_scope = keyword.control.import
      pygments_scope = Name.Namespace
   }

   .function_name : style {
      color = cyan
      textmate_scope = entity.name.function
      pygments_scope = Name.Function
   }

   .whitespace : style {
      # NOOP
   }

   .variable : style {
      color = gold
      textmate_scope = variable
      pygments_scope = Name.Variable
   }
}

contexts [] {
   main : context {
      : include "comment" ;

      : include "import" ;

      : include "function_declaration" ;

      : include "rule" ;

      : include "illegal" ;
   }

   import : context {
      : inline_push {
         regex          \= (import)([ \t]*)(\()
         styles []       = .import, .whitespace, .punctuation;
         : pop {
            regex       \= (\))
            styles []    = .punctuation;
         }
         : include "string" ;
         : include "comment" ;
         : include "illegal" ;
      }
      : inline_push {
         regex          \= (import)([ \t]*)(\")
         styles []       = .import, .whitespace, .punctuation;
         default_style   = .text
         : pop {
            regex       \= (\")
            styles []    = .punctuation;
         }
      }
   }

   rule : context {
      : inline_push {
         regex          \= ([^ {]+)([ \t]*)(\{)
         styles []       = .text, .whitespace, .punctuation;
         : pop {
            regex       \= (\})
            styles []    = .punctuation;
         }
         : include "comment" ;
         : include "shell" ;
         : include "function_call" ;
         : include "illegal" ;
      }
   }

   function_declaration: context {
      : inline_push {
         regex \= (func)([ \t]+)([a-zA-Z_][a-zA-Z_]*)(\()(\))([ \t]+)({)
         styles [] = .keyword, .whitespace, .function_name, .punctuation, .punctuation, .whitespace, .punctuation;
         : pop {
            regex \= (\})
            styles [] = .punctuation;
         }
         : include "comment";
      }
   }

   function_call : context {
      : inline_push {
         regex \= ([ \t]+)([a-zA-Z_]+)([ \t]+)
         styles[] = .whitespace, .keyword, .whitespace;
         : eol_pop {}
         default_style   = .text
      }
   }

   shell : context {
      : inline_push {
         regex \= ([ \t]+)(shell)([ \t]+)
         styles[] = .whitespace, .keyword, .whitespace;
         : eol_pop {}
         : pattern {
            regex \= (\$[^ ]+)
            styles [] = .variable;
         }
         : pattern {
            regex \= ([^\s]+)
            styles [] = .text;
         }
      }
   }

   numeric : context {
      : pattern {
         regex          \= (\b\d+)
         styles []       = .numeric;
      }
   }

   string : context {
      : inline_push {
         regex         \= (")
         styles []      = .punctuation;
         : pop {
            regex \= (")
            styles [] = .punctuation;
         }
         : pattern {
            regex      \= (\\(?:\\|"))
            styles [] = .text;
         }
         : pattern {
            regex      \= ([^"\\]+)
            styles [] = .text;
         }
      }
   }

   illegal : context {
      : pattern {
         regex          \= ([^\s])
         styles []       = .illegal;
      }
   }

   comment : context {
      : pattern {
         regex          \= (//.*)
         styles []       = .comment;
      }
   }
}
